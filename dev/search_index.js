var documenterSearchIndex = {"docs":
[{"location":"api/core/#Core-Types-and-Functions","page":"Core Types","title":"Core Types and Functions","text":"The core API for evolving domain simulations.","category":"section"},{"location":"api/core/#Main-Types","page":"Core Types","title":"Main Types","text":"","category":"section"},{"location":"api/core/#Core-Functions","page":"Core Types","title":"Core Functions","text":"","category":"section"},{"location":"api/core/#Geometry-Evolution","page":"Core Types","title":"Geometry Evolution","text":"","category":"section"},{"location":"api/core/#Accessing-Current-State","page":"Core Types","title":"Accessing Current State","text":"","category":"section"},{"location":"api/core/#Evolver-Interface","page":"Core Types","title":"Evolver Interface","text":"These are the methods that any level set evolver backend must implement:","category":"section"},{"location":"api/core/#EvolvingDomains.EvolvingDiscreteGeometry","page":"Core Types","title":"EvolvingDomains.EvolvingDiscreteGeometry","text":"EvolvingDiscreteGeometry{E<:AbstractLevelSetEvolver}\n\nA wrapper that couples a level set evolver with a GridapEmbedded DiscreteGeometry.\n\nFields\n\nevolver: The backend that evolves the level set (implements AbstractLevelSetEvolver)\nbg_model: The background CartesianDiscreteModel\ngeometry: The current DiscreteGeometry (lazily regenerated when dirty)\ngeometry_dirty: Whether geometry needs rebuild (set after advance!)\ncached_cut: Cached EmbeddedDiscretization (lazily computed)\n\nPerformance Features\n\nLazy geometry rebuild: only rebuilds when accessed AND dirty\nCached cut geometry: avoids redundant cut() calls within same time step\n\nExample\n\neg = EvolvingDiscreteGeometry(evolver, model)\nadvance!(eg, 0.01)\ngeo = current_geometry(eg)   # Rebuilds geometry (lazy)\ncut_geo = current_cut(eg)    # Computes cut, caches result\ncut_geo2 = current_cut(eg)   # Returns cached, no recomputation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.AbstractLevelSetEvolver","page":"Core Types","title":"EvolvingDomains.AbstractLevelSetEvolver","text":"AbstractLevelSetEvolver\n\nAbstract type for level set evolution backends.\n\nAny backend must implement:\n\nevolve!(evolver, Δt): Advance the level set by time Δt\ncurrent_values(evolver): Return the current nodal level set values\ncurrent_time(evolver): Return the current time\nreinitialize!(evolver): Restore signed distance property\ngrid_coords(evolver): Return the grid node coordinates\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.LevelSetMethodsEvolver","page":"Core Types","title":"EvolvingDomains.LevelSetMethodsEvolver","text":"LevelSetMethodsEvolver <: AbstractLevelSetEvolver\n\nA level set evolver backend using LevelSetMethods.jl.\n\nFields\n\nequation: The LevelSetEquation from LevelSetMethods.jl\ncoords: Node coordinates as Gridap VectorValues  \nvelocity_source: The velocity source (AbstractVelocitySource or nothing)\nvelocity_buffer: Mutable buffer for velocity values (used with update_func)\n\nVelocity Modes\n\nStatic: Velocity sampled once at construction, never updated\nDynamic: Velocity re-sampled before each RK stage via update_func callback\n\nExample\n\n# Static velocity\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ0,\n    velocity = StaticFunctionVelocity(x -> (1.0, 0.0))\n)\n\n# FE-coupled velocity\nvel_source = FEVelocitySource(velocity_fh, model)\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ0,\n    velocity = vel_source\n)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.advance!","page":"Core Types","title":"EvolvingDomains.advance!","text":"advance!(eg::EvolvingDiscreteGeometry, Δt::Real; velocity=nothing, lazy=true)\n\nAdvance the geometry by time Δt. This evolves the level set.\n\nArguments\n\nΔt: Time step size\nvelocity: Optional velocity source to use for this advance\nlazy: If true (default), defer geometry rebuild until accessed\n\nPerformance\n\nWith lazy=true, geometry and cut are only rebuilt when accessed via current_geometry() or current_cut(). This avoids redundant rebuilds if you access the same geometry multiple times.\n\nExample\n\n# Using configured velocity (from evolver construction)\nadvance!(eg, 0.01)\n\n# With FE-coupled velocity\nvelocity_fh = solve_stokes(current_geometry(eg))\nadvance!(eg, 0.01; velocity=FEVelocitySource(velocity_fh, model))\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.reinitialize!","page":"Core Types","title":"EvolvingDomains.reinitialize!","text":"reinitialize!(evolver::AbstractLevelSetEvolver)\n\nRestore the signed distance property of the level set.\n\n\n\n\n\nreinitialize!(eg::EvolvingDiscreteGeometry)\n\nRestore the signed distance property. Marks geometry as dirty.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.invalidate_cache!","page":"Core Types","title":"EvolvingDomains.invalidate_cache!","text":"invalidate_cache!(eg::EvolvingDiscreteGeometry)\n\nForce invalidation of cached geometry and cut. Useful when external changes affect the geometry (e.g., manual level set modification).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_geometry","page":"Core Types","title":"EvolvingDomains.current_geometry","text":"current_geometry(eg::EvolvingDiscreteGeometry) -> DiscreteGeometry\n\nReturn the current DiscreteGeometry (for use with cut). Rebuilds geometry lazily if dirty.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_cut","page":"Core Types","title":"EvolvingDomains.current_cut","text":"current_cut(eg::EvolvingDiscreteGeometry) -> EmbeddedDiscretization\n\nReturn the current cut geometry, with caching. Computes cut(bg_model, geometry) only if not already cached.\n\nThis is more efficient than calling cut(model, current_geometry(eg)) multiple times within the same time step.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_time","page":"Core Types","title":"EvolvingDomains.current_time","text":"current_time(evolver::AbstractLevelSetEvolver) -> Float64\n\nReturn the current simulation time.\n\n\n\n\n\ncurrent_time(eg::EvolvingDiscreteGeometry) -> Float64\n\nReturn the current simulation time.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_levelset","page":"Core Types","title":"EvolvingDomains.current_levelset","text":"current_levelset(eg::EvolvingDiscreteGeometry) -> Vector{Float64}\n\nReturn the current nodal level set values.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.evolve!","page":"Core Types","title":"EvolvingDomains.evolve!","text":"evolve!(evolver::AbstractLevelSetEvolver, Δt::Real)\n\nAdvance the level set by time Δt. Modifies evolver in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_values","page":"Core Types","title":"EvolvingDomains.current_values","text":"current_values(evolver::AbstractLevelSetEvolver) -> Vector{Float64}\n\nReturn the current nodal values of the level set function.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.supports_velocity_update","page":"Core Types","title":"EvolvingDomains.supports_velocity_update","text":"supports_velocity_update(evolver::AbstractLevelSetEvolver) -> Bool\n\nReturn whether this evolver supports runtime velocity updates.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/naoufelcre/EvolvingDomains.jl\")\n\n# Also install the level set backend (not yet registered)\nPkg.add(url=\"https://github.com/maltezfaria/LevelSetMethods.jl\")","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"EvolvingDomains.jl builds on top of several Julia packages:\n\nGridap.jl: Finite element framework\nGridapEmbedded.jl: Cut-cell methods for embedded boundaries\nLevelSetMethods.jl: High-order level set advection\n\nThese will be installed automatically as dependencies.","category":"section"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/#1.-Create-a-Background-Grid","page":"Getting Started","title":"1. Create a Background Grid","text":"using Gridap\n\ndomain = (0.0, 1.0, 0.0, 1.0)\npartition = (50, 50)\nmodel = CartesianDiscreteModel(domain, partition)","category":"section"},{"location":"getting_started/#2.-Define-Initial-Geometry","page":"Getting Started","title":"2. Define Initial Geometry","text":"The geometry is defined implicitly via a level set function phi(x):\n\nphi  0: Inside the domain\nphi = 0: Interface\nphi  0: Outside\n\n# Circle centered at (0.5, 0.5) with radius 0.2\nR = 0.2\nϕ₀(x) = R - sqrt((x[1]-0.5)^2 + (x[2]-0.5)^2)","category":"section"},{"location":"getting_started/#3.-Create-the-Evolver-and-Evolving-Geometry","page":"Getting Started","title":"3. Create the Evolver and Evolving Geometry","text":"using EvolvingDomains\nusing LevelSetMethods\n\n# Define velocity field\nu(x) = (1.0, 0.0)  # Constant rightward flow\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ₀,\n    velocity = u,\n    spatial_scheme = :WENO5,\n    bc = :Neumann\n)\n\n# Create evolving geometry wrapper\neg = EvolvingDiscreteGeometry(evolver, model)","category":"section"},{"location":"getting_started/#4.-Time-Stepping","page":"Getting Started","title":"4. Time Stepping","text":"using GridapEmbedded\n\nfor step in 1:100\n    advance!(eg, 0.01)  # Move geometry\n\n    # Use current geometry with Gridap\n    geo = current_geometry(eg)\n    cut_geo = cut(model, geo)\n\n    # ... solve physics on cut_geo ...\nend","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Examples for complete working code\nAPI Reference for detailed function documentation","category":"section"},{"location":"examples/#Examples-of-moving-domain-construction","page":"Examples","title":"Examples of moving domain construction","text":"Simple construction of moving domains","category":"section"},{"location":"examples/#Example-1:-Advecting-a-Circle","page":"Examples","title":"Example 1: Advecting a Circle","text":"A simple example advecting a circle with constant velocity.\n\nusing EvolvingDomains\nusing Gridap, GridapEmbedded\nusing LevelSetMethods\n\n# Domain setup\ndomain = (0.0, 2.0, 0.0, 1.0)\npartition = (100, 50)\nmodel = CartesianDiscreteModel(domain, partition)\n\n# Initial circle at left side\nR = 0.2\ncenter = (0.3, 0.5)\nϕ₀(x) = R - sqrt((x[1]-center[1])^2 + (x[2]-center[2])^2)\n\n# Constant rightward velocity\nu(x) = (1.0, 0.0)\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ₀,\n    velocity = u,\n    spatial_scheme = :WENO5,\n    bc = :Neumann\n)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Time stepping\nΔt = 0.01\nT_final = 1.0\nnsteps = Int(T_final / Δt)\n\nfor step in 1:nsteps\n    advance!(eg, Δt)\n\n    # Reinitialize periodically\n    if step % 10 == 0\n        reinitialize!(eg)\n    end\n\n    # Access geometry if needed\n    cut_geo = current_cut(eg)\n    # ... solve physics here ...\nend\n\nprintln(\"Final time: \", current_time(eg))\n\nResults\n\n(Image: Contour) (Image: Grid) (Image: Cut Mesh)","category":"section"},{"location":"examples/#Example-2:-Rotating-Zalesak-Disk","page":"Examples","title":"Example 2: Rotating Zalesak Disk","text":"The classic benchmark for level set methods: a slotted disk under rigid body rotation.\n\nusing EvolvingDomains\nusing Gridap, GridapEmbedded\nusing LevelSetMethods\n\n# Domain: [-0.5, 0.5]²\ndomain = (-0.5, 0.5, -0.5, 0.5)\npartition = (100, 100)\nmodel = CartesianDiscreteModel(domain, partition)\n\n# Zalesak disk\nfunction zalesak_disk(x)\n    cx, cy = 0.0, 0.25\n    radius = 0.15\n    slot_width = 0.05\n    slot_height = 0.25\n\n    d_circle = sqrt((x[1] - cx)^2 + (x[2] - cy)^2) - radius\n\n    xmin, xmax = cx - slot_width/2, cx + slot_width/2\n    ymin, ymax = cy - radius, cy - radius + slot_height\n\n    dx = max(xmin - x[1], x[1] - xmax, 0.0)\n    dy = max(ymin - x[2], x[2] - ymax, 0.0)\n    inside_slot = (xmin ≤ x[1] ≤ xmax) && (ymin ≤ x[2] ≤ ymax)\n    d_slot = inside_slot ? -min(x[1]-xmin, xmax-x[1], x[2]-ymin, ymax-x[2]) : sqrt(dx^2 + dy^2)\n\n    return max(-d_circle, d_slot)\nend\n\n# Rigid body rotation about origin\nω = 2π  # One revolution in T=1\nu(x) = (-ω * x[2], ω * x[1])\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = zalesak_disk,\n    velocity = u,\n    spatial_scheme = :WENO5,\n    integrator = :RK3,\n    bc = :Neumann\n)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Time stepping: one full revolution\nΔt = 0.01\nT_period = 1.0\nnsteps = Int(T_period / Δt)\n\nfor step in 1:nsteps\n    advance!(eg, Δt)\n\n    if step % 10 == 0\n        reinitialize!(eg)\n    end\nend\n\nprintln(\"Completed one revolution at t = \", current_time(eg))\n\nResults\n\n(Image: Contour) (Image: Grid) (Image: Cut Mesh)","category":"section"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"A practical guide to implementing moving domain simulations with FE-coupled level set advection.","category":"section"},{"location":"user_guide/#Architecture-Overview","page":"User Guide","title":"Architecture Overview","text":"┌─────────────────────────────────────────────────────────────────┐\n│                     Your Simulation Code                        │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │\n│  │ Physics      │  │ Geometry     │  │ Time Loop            │  │\n│  │ (Stokes,     │→ │ Evolution    │→ │ advance!, solve,     │  │\n│  │  Poisson)    │  │              │  │ repeat               │  │\n│  └──────────────┘  └──────────────┘  └──────────────────────┘  │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                     EvolvingDomains Package                     │\n│  ┌──────────────────────────────────────────────────────────┐  │\n│  │ EvolvingDiscreteGeometry                                  │  │\n│  │ • Manages geometry state                                  │  │\n│  │ • advance!(eg, Δt) → moves interface                      │  │\n│  │ • current_geometry(eg) → DiscreteGeometry for Gridap     │  │\n│  └──────────────────────────────────────────────────────────┘  │\n│                              ↓                                  │\n│  ┌──────────────────────────────────────────────────────────┐  │\n│  │ AbstractLevelSetEvolver (backend interface)               │  │\n│  │ • LevelSetMethodsEvolver (uses LevelSetMethods.jl)       │  │\n│  │ • evolve!, current_values, reinitialize!                 │  │\n│  └──────────────────────────────────────────────────────────┘  │\n│                              ↓                                  │\n│  ┌──────────────────────────────────────────────────────────┐  │\n│  │ VelocitySource (velocity abstraction)                     │  │\n│  │ • StaticFunctionVelocity      - u(x)                     │  │\n│  │ • TimeDependentVelocity       - u(x,t)                   │  │\n│  │ • FEVelocitySource + NarrowBand - FE velocity (FAST)     │  │\n│  └──────────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│              External Dependencies                              │\n│  • LevelSetMethods.jl (WENO5, RK3, reinitialization)           │\n│  • Gridap + GridapEmbedded (FE spaces, cut meshes)             │\n└─────────────────────────────────────────────────────────────────┘","category":"section"},{"location":"user_guide/#The-Level-Set-Function","page":"User Guide","title":"The Level Set Function","text":"The initial_ls parameter expects a callable function ϕ₀(x) where:\n\nx is a coordinate tuple (x[1], x[2]) for 2D\nReturns a Float64 value representing the signed distance\nϕ < 0: Inside the domain (physical region)\nϕ = 0: Interface (boundary)\nϕ > 0: Outside","category":"section"},{"location":"user_guide/#Initial-Geometry:-Analytical-Functions","page":"User Guide","title":"Initial Geometry: Analytical Functions","text":"Define geometry using closed-form expressions. This is the most robust approach.","category":"section"},{"location":"user_guide/#Primitives","page":"User Guide","title":"Primitives","text":"# Circle: center (cx, cy), radius R\nϕ_circle(x) = sqrt((x[1] - cx)^2 + (x[2] - cy)^2) - R\n\n# Rectangle: centered at (cx, cy), half-widths (hw, hh)\nfunction ϕ_rectangle(x)\n    dx = abs(x[1] - cx) - hw\n    dy = abs(x[2] - cy) - hh\n    outside = sqrt(max(dx, 0)^2 + max(dy, 0)^2)\n    inside = min(max(dx, dy), 0.0)\n    return outside + inside\nend\n\n# Ellipse: center (cx, cy), semi-axes (a, b)\nϕ_ellipse(x) = sqrt(((x[1]-cx)/a)^2 + ((x[2]-cy)/b)^2) - 1.0\n\n# Half-plane: normal (nx, ny), point (px, py)\nϕ_halfplane(x) = (x[1] - px) * nx + (x[2] - py) * ny","category":"section"},{"location":"user_guide/#CSG-Operations","page":"User Guide","title":"CSG Operations","text":"Combine primitives using min/max operations (Constructive Solid Geometry):\n\n# Union: A ∪ B (inside either A or B)\nϕ_union(x) = min(ϕ_A(x), ϕ_B(x))\n\n# Intersection: A ∩ B (inside both A and B)\nϕ_intersection(x) = max(ϕ_A(x), ϕ_B(x))\n\n# Difference: A \\ B (inside A, outside B)\nϕ_difference(x) = max(ϕ_A(x), -ϕ_B(x))\n\n# Complement: ¬A (outside A)\nϕ_complement(x) = -ϕ_A(x)","category":"section"},{"location":"user_guide/#Example:-Zalesak-Disk","page":"User Guide","title":"Example: Zalesak Disk","text":"A classic test case: a slotted disk with a rectangular notch.\n\nfunction zalesak_disk(x; center=(0.0, 0.25), radius=0.5, slot_width=0.12, slot_height=0.5)\n    cx, cy = center\n    \n    # Distance to circle (negative inside)\n    d_circle = sqrt((x[1] - cx)^2 + (x[2] - cy)^2) - radius\n    \n    # Slot rectangle\n    xmin, xmax = cx - slot_width/2, cx + slot_width/2\n    ymin, ymax = cy - radius, cy - radius + slot_height\n    \n    # Signed distance to rectangle\n    dx = max(xmin - x[1], x[1] - xmax, 0.0)\n    dy = max(ymin - x[2], x[2] - ymax, 0.0)\n    inside_slot = (xmin ≤ x[1] ≤ xmax) && (ymin ≤ x[2] ≤ ymax)\n    d_slot = inside_slot ? -min(x[1]-xmin, xmax-x[1], x[2]-ymin, ymax-x[2]) : sqrt(dx^2 + dy^2)\n    \n    # CSG: disk \\ slot = max(-ϕ_disk, ϕ_slot)\n    return max(-d_circle, d_slot)\nend","category":"section"},{"location":"user_guide/#Code-Structure-Patterns","page":"User Guide","title":"Code Structure Patterns","text":"","category":"section"},{"location":"user_guide/#Pattern-1:-One-Way-Coupling-(Prescribed-Velocity)","page":"User Guide","title":"Pattern 1: One-Way Coupling (Prescribed Velocity)","text":"Use when velocity is known analytically or from external source.\n\n# Setup\nu(x, t) = (-x[2] + 0.5, x[1] - 0.5) * cos(t)  # Time-varying rotation\nevolver = LevelSetMethodsEvolver(; velocity = u, ...)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Time loop - geometry doesn't affect velocity\nfor step in 1:N\n    advance!(eg, Δt)\n    geo = current_geometry(eg)\n    # Optional: solve physics on current geometry\nend","category":"section"},{"location":"user_guide/#Pattern-2:-Two-Way-Coupling-(FE-Velocity-from-Physics)","page":"User Guide","title":"Pattern 2: Two-Way Coupling (FE Velocity from Physics)","text":"Use when velocity comes from solving equations on the moving domain.\n\n# Setup with narrow band (FAST path)\nnx, ny = partition .+ 1\nΔx = 1.0 / partition[1]\nγ = 6 * Δx  # WENO5 needs 6 cells\next = NarrowBandExtension(γ, nx, ny)\n\n# Initial FE velocity (placeholder)\nV = FESpace(model, ReferenceFE(lagrangian, VectorValue{2,Float64}, 1))\nu₀ = interpolate_everywhere(x -> VectorValue(0.0, 0.0), V)\n\nvel_source = FEVelocitySource(u₀, model, ext)\nevolver = LevelSetMethodsEvolver(; velocity = vel_source, ...)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Time loop - velocity depends on geometry\nfor step in 1:N\n    # 1. Get current geometry\n    geo = current_geometry(eg)\n    cut_geo = cut(model, geo)\n    \n    # 2. Solve physics (e.g., Stokes)\n    velocity_fh = solve_stokes(cut_geo)\n    \n    # 3. Update velocity source\n    update_velocity!(vel_source, velocity_fh)\n    update_levelset!(vel_source, current_values(eg.evolver))\n    \n    # 4. Advance geometry\n    advance!(eg, Δt)\nend","category":"section"},{"location":"user_guide/#Key-Concepts","page":"User Guide","title":"Key Concepts","text":"","category":"section"},{"location":"user_guide/#Signed-Distance-Property","page":"User Guide","title":"Signed Distance Property","text":"For accurate advection, ϕ should be a signed distance function:\n\n|∇ϕ| = 1 everywhere\nϕ(x) = distance from x to interface\n\nUse reinitialize! periodically to restore this property:\n\nif step % 10 == 0\n    reinitialize!(eg.evolver)\nend","category":"section"},{"location":"user_guide/#CFL-Condition","page":"User Guide","title":"CFL Condition","text":"Time step must satisfy:\n\nΔt < Δx / max(|u|)\n\nFor WENO5 + RK3, use CFL ≈ 0.5:\n\nΔx = 1.0 / partition[1]\nu_max = maximum(norm.(velocities))\nΔt = 0.5 * Δx / u_max","category":"section"},{"location":"user_guide/#Narrow-Band-Concept","page":"User Guide","title":"Narrow Band Concept","text":"Velocity is only needed near the interface (|ϕ| < γ):\n\nInside band: Velocity from FE solution or extended\nOutside band: Velocity = 0 (doesn't affect interface)\n\nBandwidth γ should cover the stencil:\n\nγ = 6 * Δx  # WENO5 uses 6-point stencil","category":"section"},{"location":"user_guide/#Performance-Optimization","page":"User Guide","title":"Performance Optimization","text":"","category":"section"},{"location":"user_guide/#Do's","page":"User Guide","title":"Do's ✓","text":"# ✓ Use NarrowBandExtension for FE velocities (474× faster)\next = NarrowBandExtension(γ, nx, ny)\nvel_source = FEVelocitySource(fh, model, ext)\nupdate_levelset!(vel_source, ϕ_values)\n\n# ✓ Pre-allocate coordinate arrays\ncoords = [Tuple(c) for c in Gridap.Geometry.get_node_coordinates(trian)]\n\n# ✓ Reuse FE spaces when possible\nV = FESpace(model, reffe)  # Create once\nfor step in 1:N\n    uh = interpolate_everywhere(u_func, V)  # Reuse V\nend\n\n# ✓ Use the cached cut geometry\ncut_geo = current_cut(eg)  # Cached, fast","category":"section"},{"location":"user_guide/#Don'ts","page":"User Guide","title":"Don'ts ✗","text":"# ✗ Don't forget to update level set for narrow band\nvel_source = FEVelocitySource(fh, model, ext)\n# Missing: update_levelset!(vel_source, ϕ_values)\n# Result: Falls back to slow point evaluation\n\n# ✗ Don't recreate FE spaces each step\nfor step in 1:N\n    V = FESpace(model, reffe)  # ✗ Expensive!\nend\n\n# ✗ Don't use tiny time steps unnecessarily\nΔt = 1e-6  # ✗ Too small if CFL allows larger\n\n# ✗ Don't call reinitialize! every step\nfor step in 1:N\n    reinitialize!(evolver)  # ✗ Expensive, do every 10-20 steps\nend","category":"section"},{"location":"user_guide/#Common-Pitfalls","page":"User Guide","title":"Common Pitfalls","text":"","category":"section"},{"location":"user_guide/#Level-Set-Blows-Up","page":"User Guide","title":"Level Set Blows Up","text":"Symptom: ϕ values become very large or NaN\n\nFix:\n\nΔt = 0.5 * Δx / u_max  # Respect CFL\nif step % 10 == 0\n    reinitialize!(eg.evolver)\nend","category":"section"},{"location":"user_guide/#Interface-Disappears","page":"User Guide","title":"Interface Disappears","text":"Symptom: Geometry becomes empty or fills entire domain\n\nFix: Check your sign convention — ϕ < 0 is INSIDE.","category":"section"},{"location":"user_guide/#Slow-Performance","page":"User Guide","title":"Slow Performance","text":"Fix: Use narrow band extension:\n\next = NarrowBandExtension(γ, nx, ny)\nvel_source = FEVelocitySource(fh, model, ext)\nupdate_levelset!(vel_source, current_values(evolver))","category":"section"},{"location":"api/velocity/#Velocity-Sources","page":"Velocity Sources","title":"Velocity Sources","text":"EvolvingDomains.jl provides a flexible abstraction for velocity fields.","category":"section"},{"location":"api/velocity/#Velocity-Source-Types","page":"Velocity Sources","title":"Velocity Source Types","text":"","category":"section"},{"location":"api/velocity/#Velocity-Extension-Strategies","page":"Velocity Sources","title":"Velocity Extension Strategies","text":"When using FE velocities that are only defined inside the domain, velocity extension strategies determine how to compute velocities at interface nodes.","category":"section"},{"location":"api/velocity/#Functions","page":"Velocity Sources","title":"Functions","text":"","category":"section"},{"location":"api/velocity/#EvolvingDomains.AbstractVelocitySource","page":"Velocity Sources","title":"EvolvingDomains.AbstractVelocitySource","text":"AbstractVelocitySource\n\nAbstract type for velocity sources used in level set advection.\n\nImplementations must define:\n\nsample_velocity(source, coords, t): Sample velocity at coordinates and time\nis_time_dependent(source): Whether velocity varies with time\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.StaticFunctionVelocity","page":"Velocity Sources","title":"EvolvingDomains.StaticFunctionVelocity","text":"StaticFunctionVelocity{F, E<:AbstractVelocityExtension} <: AbstractVelocitySource\n\nVelocity source from a static function u(x) -> velocity. The velocity is time-independent and sampled once per call.\n\nFields\n\nfunc: Function x -> SVector{2,Float64} or tuple\nextension: Velocity extension strategy\n\nExample\n\nu(x) = (1.0, 0.0)  # Constant rightward flow\nvel_source = StaticFunctionVelocity(u)\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.TimeDependentVelocity","page":"Velocity Sources","title":"EvolvingDomains.TimeDependentVelocity","text":"TimeDependentVelocity{F, E<:AbstractVelocityExtension} <: AbstractVelocitySource\n\nVelocity source from a time-dependent function u(x, t) -> velocity.\n\nFields\n\nfunc: Function (x, t) -> SVector{2,Float64} or tuple\nextension: Velocity extension strategy\n\nExample\n\nu(x, t) = (-x[2], x[1]) * cos(t)  # Oscillating rotation\nvel_source = TimeDependentVelocity(u)\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.FEVelocitySource","page":"Velocity Sources","title":"EvolvingDomains.FEVelocitySource","text":"FEVelocitySource{V, M, E<:AbstractVelocityExtension} <: AbstractVelocitySource\n\nVelocity source wrapping a Gridap CellField (FEFunction) with optimized sampling.\n\nSupports two sampling modes:\n\nPoint evaluation (fallback): Calls fh(Point(x,y)) for each node\nFast DOF path (with NarrowBandExtension): Direct DOF array access + extension\n\nFields\n\nfe_function: Current velocity CellField (mutable for in-place updates)\nbg_model: Background CartesianDiscreteModel\nextension: Velocity extension strategy\nlevelset_values: Level set values at grid nodes (for narrow band)\ninside_mask: Nodes inside physical domain (ϕ < 0)\n\nExample\n\n# Basic usage (point evaluation)\nvel_source = FEVelocitySource(velocity_fh, model)\n\n# Fast path with narrow band extension\nnx, ny = partition .+ 1\nγ = 6 * Δx  # 6 cells bandwidth for WENO5\next = NarrowBandExtension(γ, nx, ny)\nvel_source = FEVelocitySource(velocity_fh, model, ext)\n\n# Update level set values (needed for narrow band)\nupdate_levelset!(vel_source, ϕ_values)\n\n# When velocity is updated from new FE solve\nupdate_velocity!(vel_source, new_velocity_fh)\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.AbstractVelocityExtension","page":"Velocity Sources","title":"EvolvingDomains.AbstractVelocityExtension","text":"AbstractVelocityExtension\n\nAbstract type for velocity extension strategies.\n\nUsed when evaluating velocity at points outside the physical domain (e.g., ghost points near cut cells). Implementations define how to extrapolate or extend the velocity field.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.NoExtension","page":"Velocity Sources","title":"EvolvingDomains.NoExtension","text":"NoExtension <: AbstractVelocityExtension\n\nDefault extension: use velocity as-is (assumes all sample points are valid).\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.ZeroExtension","page":"Velocity Sources","title":"EvolvingDomains.ZeroExtension","text":"ZeroExtension <: AbstractVelocityExtension\n\nZero extension: return zero velocity for points outside domain.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.ConstantExtension","page":"Velocity Sources","title":"EvolvingDomains.ConstantExtension","text":"ConstantExtension <: AbstractVelocityExtension\n\nConstant extension: use a fixed velocity for points outside domain.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.NarrowBandExtension","page":"Velocity Sources","title":"EvolvingDomains.NarrowBandExtension","text":"NarrowBandExtension <: AbstractVelocityExtension\n\nOsher-Sethian narrow band velocity extension.\n\nExtends velocity from inside nodes to a narrow band around the interface using constant extrapolation in the normal direction (∇u · ∇ϕ = 0).\n\nFields\n\nbandwidth: Width of narrow band γ (should be k × Δx where k ≥ stencil width)\nnx, ny: Grid dimensions for 2D neighbor lookup\nmax_iters: Maximum extension iterations (default: 50)\n\nNotes\n\nVelocity outside the narrow band is set to zero, as it doesn't affect level set evolution near the interface.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.sample_velocity","page":"Velocity Sources","title":"EvolvingDomains.sample_velocity","text":"sample_velocity(source::AbstractVelocitySource, coords, t) -> Vector{SVector{2,Float64}}\n\nSample velocity at grid coordinates and time t. Returns a vector of 2D velocity vectors, one per coordinate.\n\n\n\n\n\nsample_velocity(source::FEVelocitySource, coords, t)\n\nSample velocity at grid coordinates.\n\nIf extension is NarrowBandExtension and levelset_values is set, uses the fast DOF-based path with narrow band extension. Otherwise falls back to point evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.is_time_dependent","page":"Velocity Sources","title":"EvolvingDomains.is_time_dependent","text":"is_time_dependent(source::AbstractVelocitySource) -> Bool\n\nReturn whether velocity varies with time. If false, velocity is sampled once at construction and cached.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.update_velocity!","page":"Velocity Sources","title":"EvolvingDomains.update_velocity!","text":"update_velocity!(evolver::AbstractLevelSetEvolver, velocity_source, t)\n\nUpdate the evolver's internal velocity representation from an external source. Called before each time step when using time-dependent or FE-coupled velocities.\n\nDefault implementation does nothing (for static velocity cases). Override this for evolvers that support velocity updates.\n\n\n\n\n\nupdate_velocity!(source::FEVelocitySource, new_fh)\n\nUpdate the wrapped FE velocity function with a new solution.\n\n\n\n\n\nupdate_velocity!(evolver::LevelSetMethodsEvolver, new_source::AbstractVelocitySource, t)\n\nUpdate the evolver's velocity source. The new source will be sampled at the next RK stage via the update_func callback.\n\n\n\n\n\nupdate_velocity!(evolver::LevelSetMethodsEvolver, fh, t)\n\nConvenience method: if an FEVelocitySource is already set, update its wrapped function. Otherwise, create a new FEVelocitySource.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.extend_velocity","page":"Velocity Sources","title":"EvolvingDomains.extend_velocity","text":"extend_velocity(ext::AbstractVelocityExtension, vel, x, domain_indicator)\n\nExtend velocity vel at point x. The domain_indicator function returns whether a point is inside the physical domain.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.extend_velocity_narrow_band!","page":"Velocity Sources","title":"EvolvingDomains.extend_velocity_narrow_band!","text":"extend_velocity_narrow_band!(vel, ϕ, inside_mask, ext::NarrowBandExtension)\n\nExtend velocity from inside nodes to narrow band using neighbor propagation.\n\nUses iterative relaxation: each outside node in the narrow band copies velocity from its neighbor with smallest |ϕ| that already has velocity.\n\nThis approximates the PDE extension ∇u · ∇ϕ = 0 (constant in normal direction).\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.update_levelset!","page":"Velocity Sources","title":"EvolvingDomains.update_levelset!","text":"update_levelset!(source::FEVelocitySource, ϕ::Vector{Float64})\n\nUpdate the level set values for the narrow band extension. Also recomputes the inside_mask.\n\n\n\n\n\n","category":"function"},{"location":"#EvolvingDomains.jl","page":"Home","title":"EvolvingDomains.jl","text":"A Julia package for evolving domain simulations in the Gridap Ecosystem.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"EvolvingDomains.jl provides basic structure to solves PDE's on moving domains. It can be used as a basic building block for Multi-Physics simulation building with operator splitting techniques. It is designed to fit in the Gridap.jl ecosystem.","category":"section"},{"location":"#Package-Contents","page":"Home","title":"Package Contents","text":"","category":"section"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"Pages = [\n    \"getting_started.md\",\n    \"examples.md\",\n    \"api/core.md\",\n    \"api/velocity.md\",\n    \"api/external.md\",\n]\nDepth = 2","category":"section"},{"location":"api/external/#External-Solver-Interface","page":"External Solver Interface","title":"External Solver Interface","text":"EvolvingDomains.jl provides a clean API for integrating with external Cartesian-grid solvers for operator-splitting workflows.","category":"section"},{"location":"api/external/#Grid-Information","page":"External Solver Interface","title":"Grid Information","text":"","category":"section"},{"location":"api/external/#Domain-Masks","page":"External Solver Interface","title":"Domain Masks","text":"These functions help identify which grid nodes are inside the domain or near the interface:","category":"section"},{"location":"api/external/#Level-Set-Injection","page":"External Solver Interface","title":"Level Set Injection","text":"For external solvers that evolve the level set independently:","category":"section"},{"location":"api/external/#Typical-Usage-Pattern","page":"External Solver Interface","title":"Typical Usage Pattern","text":"# Get grid metadata\ninfo = grid_info(eg)\nΔx, Δy = info.spacing\nnx, ny = info.dims\n\n# Get current level set and masks\nϕ = current_levelset(eg)\ninside = domain_mask(ϕ)\nnear_interface = narrow_band_mask(ϕ, 6 * Δx)\n\n# External solver computes new level set\nϕ_new = my_external_solver(info, ϕ, Δt)\n\n# Inject back into EvolvingDomains\nset_levelset!(eg, ϕ_new)\nreinitialize!(eg)  # Restore signed distance property\n\n# Continue with CutFEM\ncut_geo = current_cut(eg)","category":"section"},{"location":"api/external/#EvolvingDomains.CartesianGridInfo","page":"External Solver Interface","title":"EvolvingDomains.CartesianGridInfo","text":"CartesianGridInfo{N}\n\nImmutable struct containing Cartesian grid metadata for external solvers.\n\nFields\n\norigin: Grid origin coordinates (NTuple{N,Float64})\nspacing: Cell sizes Δx, Δy, ... (NTuple{N,Float64}) \ndims: Node counts nx, ny, ... (NTuple{N,Int})\ncells: Cell counts (dims .- 1) (NTuple{N,Int})\n\nExample\n\ninfo = CartesianGridInfo(model)\nΔx, Δy = info.spacing\nnx, ny = info.dims\n\n\n\n\n\n","category":"type"},{"location":"api/external/#EvolvingDomains.grid_info","page":"External Solver Interface","title":"EvolvingDomains.grid_info","text":"grid_info(eg::EvolvingDiscreteGeometry) -> CartesianGridInfo\n\nGet structured grid metadata for external solvers.\n\nExample\n\ninfo = grid_info(eg)\nΔx, Δy = info.spacing\nnx, ny = info.dims\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.domain_mask","page":"External Solver Interface","title":"EvolvingDomains.domain_mask","text":"domain_mask(ϕ::Vector{Float64}) -> BitVector\n\nReturns a mask where true indicates inside the domain (ϕ < 0).\n\nExample\n\nϕ = current_levelset(eg)\nmask = domain_mask(ϕ)\ninside_nodes = findall(mask)\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.narrow_band_mask","page":"External Solver Interface","title":"EvolvingDomains.narrow_band_mask","text":"narrow_band_mask(ϕ::Vector{Float64}, bandwidth::Real) -> BitVector\n\nReturns a mask for nodes within bandwidth of the interface (|ϕ| < bandwidth). Useful for narrow-band level set methods.\n\nArguments\n\nϕ: Level set values at grid nodes\nbandwidth: Width of the narrow band (typically k × Δx for stencil width k)\n\nExample\n\nϕ = current_levelset(eg)\ninfo = grid_info(eg)\nγ = 6 * info.spacing[1]  # 6 cells for WENO5\nband = narrow_band_mask(ϕ, γ)\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.set_levelset!","page":"External Solver Interface","title":"EvolvingDomains.set_levelset!","text":"set_levelset!(eg::EvolvingDiscreteGeometry, ϕ_new::Vector{Float64})\n\nUpdate level set from external solver. Marks geometry as dirty.\n\nThis is the primary entry point for external Cartesian-grid hyperbolic solvers to inject their computed level set values.\n\nArguments\n\neg: The evolving geometry\nϕ_new: New level set values (must match node count)\n\nExample\n\n# External solver evolves the level set\nϕ = current_levelset(eg)\nϕ_new = external_hyperbolic_step(grid_info(eg), ϕ, u_data, Δt)\n\n# Inject back and optionally reinitialize\nset_levelset!(eg, ϕ_new)\nreinitialize!(eg)\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.set_values!","page":"External Solver Interface","title":"EvolvingDomains.set_values!","text":"set_values!(evolver::AbstractLevelSetEvolver, ϕ_new::Vector{Float64})\n\nUpdate the level set values from external data. This is the injection point for external hyperbolic solvers that evolve the level set independently.\n\nArguments\n\nevolver: The level set evolver instance\nϕ_new: New level set values (must match length of current_values(evolver))\n\nExample\n\n# External solver computes new level set\nϕ_ext = external_hyperbolic_solve(info, ϕ, Δt)\n\n# Inject into evolver\nset_values!(evolver, ϕ_ext)\nreinitialize!(evolver)  # Restore signed distance property\n\n\n\n\n\nset_values!(e::LevelSetMethodsEvolver, ϕ_new::Vector{Float64})\n\nUpdate the level set values from external data.\n\nCopies ϕ_new into the internal LevelSetMethods level set array. This enables external Cartesian-grid hyperbolic solvers to inject their computed level set values.\n\nnote: Note\nAfter calling this, you may want to call reinitialize!(e) to restore the signed distance property.\n\n\n\n\n\n","category":"function"}]
}
