var documenterSearchIndex = {"docs":
[{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"visualization extension that activates automatically when GLMakie is loaded","category":"section"},{"location":"visualization/#Setup","page":"Visualization","title":"Setup","text":"To use visualization features, simply load GLMakie alongside EvolvingDomains:\n\nusing EvolvingDomains\nusing GLMakie\n\n# Create your evolving geometry...\nevolver = LevelSetMethodsEvolver(; bg_model=model, initial_ls=ϕ₀, velocity=u)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Visualization functions are now available\nfig = plot_levelset(eg)\n\nWhen the extension loads, you'll see:\n\n[ Info: EvolvingDomainsMakieExt loaded: plot_levelset(), viewer(), view_live!() available","category":"section"},{"location":"visualization/#Static-Plotting","page":"Visualization","title":"Static Plotting","text":"","category":"section"},{"location":"visualization/#plot_levelset","page":"Visualization","title":"plot_levelset","text":"Create a static plot of the current level set state.\n\nplot_levelset(eg::EvolvingDiscreteGeometry; kwargs...) -> Figure\n\nKeyword Arguments:\n\ncolormap::Symbol = :RdBu - Colormap for level set values\nshow_zero::Bool = true - Highlight the zero contour (domain boundary)\ntitle::String = \"\" - Plot title (auto-generated if empty)\nfilled::Bool = true - Use filled heatmap for the level set\n\nExample:\n\n# Basic usage\nfig = plot_levelset(eg)\n\n# Custom styling\nfig = plot_levelset(eg;\n    colormap = :viridis,\n    title = \"My Domain\",\n    show_zero = true\n)\ndisplay(fig)","category":"section"},{"location":"visualization/#plot_levelset!","page":"Visualization","title":"plot_levelset!","text":"Add level set visualization to an existing Makie axis.\n\nplot_levelset!(ax, eg::EvolvingDiscreteGeometry; kwargs...) -> Axis\n\nExample:\n\nfig = Figure(size = (1200, 400))\nax1 = Axis(fig[1, 1], title = \"Before\")\nax2 = Axis(fig[1, 2], title = \"After\")\n\n# Initial state\nplot_levelset!(ax1, eg)\n\n# ... advance simulation ...\nEvolvingDomains.advance!(eg, 0.5)\n\n# Final state\nplot_levelset!(ax2, eg)\ndisplay(fig)","category":"section"},{"location":"visualization/#Simulation-Snapshotting","page":"Visualization","title":"Simulation Snapshotting","text":"To visualize time-dependent simulations, you first need to capture snapshots during the simulation:\n\nusing EvolvingDomains\n\n# Run simulation and capture frames\nframes = SimulationFrame[]\nfor step in 1:100\n    EvolvingDomains.advance!(eg, Δt)\n    push!(frames, snapshot(eg))\nend\n\n# Create result container\nresult = SimulationResult(grid_info(eg), frames)\n\nThe snapshot() function captures:\n\nCurrent time\nLevel set values (copied)","category":"section"},{"location":"visualization/#Interactive-Viewer","page":"Visualization","title":"Interactive Viewer","text":"","category":"section"},{"location":"visualization/#viewer","page":"Visualization","title":"viewer","text":"Open an interactive viewer with a time slider to browse simulation frames.\n\nviewer(result::SimulationResult; kwargs...) -> Figure\n\nKeyword Arguments:\n\ncolormap::Symbol = :RdBu - Colormap for visualization\nwait::Bool = false - If true, block until Enter is pressed\n\nExample:\n\n# Run simulation with snapshots\nframes = SimulationFrame[]\nfor step in 1:100\n    EvolvingDomains.advance!(eg, Δt)\n    if step % 5 == 0\n        EvolvingDomains.reinitialize!(eg)\n    end\n    push!(frames, snapshot(eg))\nend\n\nresult = SimulationResult(grid_info(eg), frames)\n\n# Open interactive viewer\nviewer(result)  # Drag the slider to navigate through time\n\nThe viewer displays:\n\nHeatmap of level set values\nZero contour (domain boundary) in black\nCurrent time and frame number\nInteractive slider for frame selection","category":"section"},{"location":"visualization/#Animated-Playback","page":"Visualization","title":"Animated Playback","text":"","category":"section"},{"location":"visualization/#view_live!","page":"Visualization","title":"view_live!","text":"Play back cached simulation frames as an animation.\n\nview_live!(result::SimulationResult; kwargs...) -> Nothing\n\nKeyword Arguments:\n\nfps::Real = 30 - Frames per second for playback\nloop::Bool = false - If true, loop animation continuously\ncolormap::Symbol = :RdBu - Colormap for visualization\n\nExample:\n\n# Play animation at 15 fps\nview_live!(result; fps = 15)\n\n# Loop continuously (Ctrl+C to stop)\nview_live!(result; fps = 20, loop = true)\n\nnote: Note\nview_live! blocks until playback completes. Use loop = false (default) for single playback, or press Ctrl+C to stop a looping animation.","category":"section"},{"location":"visualization/#Complete-Example","page":"Visualization","title":"Complete Example","text":"using EvolvingDomains\nusing Gridap, GridapEmbedded\nusing LevelSetMethods\nusing GLMakie\n\n# Setup\ndomain = (-1.0, 1.0, -1.0, 1.0)\npartition = (100, 100)\nmodel = CartesianDiscreteModel(domain, partition)\n\nϕ₀(x) = 0.2 - sqrt(x[1]^2 + x[2]^2)\nu(x) = (0.5, 0.3)\n\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ₀,\n    velocity = u,\n    spatial_scheme = :WENO5,\n    bc = :Neumann\n)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Show initial state\nfig = plot_levelset(eg; title = \"Initial Configuration\")\ndisplay(fig)\n\n# Run simulation with snapshots\nframes = SimulationFrame[]\nΔt = 0.01\nfor step in 1:100\n    EvolvingDomains.advance!(eg, Δt)\n    if step % 5 == 0\n        EvolvingDomains.reinitialize!(eg)\n    end\n    push!(frames, snapshot(eg))\nend\n\nresult = SimulationResult(grid_info(eg), frames)\n\n# Interactive exploration\nviewer(result)\n\n# Or watch as animation\nview_live!(result; fps = 20)","category":"section"},{"location":"api/external/#External-Solver-Interface","page":"External Solver Interface","title":"External Solver Interface","text":"","category":"section"},{"location":"api/external/#Grid-Information","page":"External Solver Interface","title":"Grid Information","text":"","category":"section"},{"location":"api/external/#Domain-Masks","page":"External Solver Interface","title":"Domain Masks","text":"These functions help identify which grid nodes are inside the domain or near the interface:","category":"section"},{"location":"api/external/#Level-Set-Injection","page":"External Solver Interface","title":"Level Set Injection","text":"For external solvers that evolve the level set independently:","category":"section"},{"location":"api/external/#Typical-Usage-Pattern","page":"External Solver Interface","title":"Typical Usage Pattern","text":"# Get grid metadata\ninfo = grid_info(eg)\nΔx, Δy = info.spacing\nnx, ny = info.dims\n\n# Get current level set and masks\nϕ = current_levelset(eg)\ninside = domain_mask(ϕ)\nnear_interface = narrow_band_mask(ϕ, 6 * Δx)\n\n# External solver computes new level set\nϕ_new = my_external_solver(info, ϕ, Δt)\n\n# Inject back into EvolvingDomains\nset_levelset!(eg, ϕ_new)\nEvolvingDomains.reinitialize!(eg)  # Restore signed distance property\n\n# Continue with CutFEM\ncut_geo = current_cut(eg)","category":"section"},{"location":"api/external/#EvolvingDomains.CartesianGridInfo","page":"External Solver Interface","title":"EvolvingDomains.CartesianGridInfo","text":"CartesianGridInfo{N}\n\nImmutable struct containing Cartesian grid metadata for external solvers.\n\nFields\n\norigin: Grid origin coordinates (NTuple{N,Float64})\nspacing: Cell sizes Δx, Δy, ... (NTuple{N,Float64}) \ndims: Node counts nx, ny, ... (NTuple{N,Int})\ncells: Cell counts (dims .- 1) (NTuple{N,Int})\n\nExample\n\ninfo = CartesianGridInfo(model)\nΔx, Δy = info.spacing\nnx, ny = info.dims\n\n\n\n\n\n","category":"type"},{"location":"api/external/#EvolvingDomains.grid_info","page":"External Solver Interface","title":"EvolvingDomains.grid_info","text":"grid_info(eg::EvolvingDiscreteGeometry) -> CartesianGridInfo\n\nGet structured grid metadata for external solvers.\n\nExample\n\ninfo = grid_info(eg)\nΔx, Δy = info.spacing\nnx, ny = info.dims\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.domain_mask","page":"External Solver Interface","title":"EvolvingDomains.domain_mask","text":"domain_mask(ϕ::Vector{Float64}) -> BitVector\n\nReturns a mask where true indicates inside the domain (ϕ < 0).\n\nExample\n\nϕ = current_levelset(eg)\nmask = domain_mask(ϕ)\ninside_nodes = findall(mask)\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.narrow_band_mask","page":"External Solver Interface","title":"EvolvingDomains.narrow_band_mask","text":"narrow_band_mask(ϕ::Vector{Float64}, bandwidth::Real) -> BitVector\n\nReturns a mask for nodes within bandwidth of the interface (|ϕ| < bandwidth). Useful for narrow-band level set methods.\n\nArguments\n\nϕ: Level set values at grid nodes\nbandwidth: Width of the narrow band (typically k × Δx for stencil width k)\n\nExample\n\nϕ = current_levelset(eg)\ninfo = grid_info(eg)\nγ = 6 * info.spacing[1]  # 6 cells for WENO5\nband = narrow_band_mask(ϕ, γ)\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.set_levelset!","page":"External Solver Interface","title":"EvolvingDomains.set_levelset!","text":"set_levelset!(eg::EvolvingDiscreteGeometry, ϕ_new::Vector{Float64})\n\nUpdate level set from external solver. Marks geometry as dirty.\n\nThis is the primary entry point for external Cartesian-grid hyperbolic solvers to inject their computed level set values.\n\nArguments\n\neg: The evolving geometry\nϕ_new: New level set values (must match node count)\n\nExample\n\n# External solver evolves the level set\nϕ = current_levelset(eg)\nϕ_new = external_hyperbolic_step(grid_info(eg), ϕ, u_data, Δt)\n\n# Inject back and optionally reinitialize\nset_levelset!(eg, ϕ_new)\nreinitialize!(eg)\n\n\n\n\n\n","category":"function"},{"location":"api/external/#EvolvingDomains.set_values!","page":"External Solver Interface","title":"EvolvingDomains.set_values!","text":"set_values!(evolver::AbstractLevelSetEvolver, ϕ_new::Vector{Float64})\n\nUpdate the level set values from external data. This is the injection point for external hyperbolic solvers that evolve the level set independently.\n\nArguments\n\nevolver: The level set evolver instance\nϕ_new: New level set values (must match length of current_values(evolver))\n\nExample\n\n# External solver computes new level set\nϕ_ext = external_hyperbolic_solve(info, ϕ, Δt)\n\n# Inject into evolver\nset_values!(evolver, ϕ_ext)\nreinitialize!(evolver)  # Restore signed distance property\n\n\n\n\n\nset_values!(e::LevelSetMethodsEvolver, ϕ_new::Vector{Float64})\n\nUpdate the level set values from external data.\n\nCopies ϕ_new into the internal LevelSetMethods level set array. This enables external Cartesian-grid hyperbolic solvers to inject their computed level set values.\n\nnote: Note\nAfter calling this, you may want to call reinitialize!(e) to restore the signed distance property.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Types-and-Functions","page":"Core Types","title":"Types and Functions","text":"","category":"section"},{"location":"api/core/#Main-Types","page":"Core Types","title":"Main Types","text":"","category":"section"},{"location":"api/core/#Core-Functions","page":"Core Types","title":"Core Functions","text":"","category":"section"},{"location":"api/core/#Geometry-Evolution","page":"Core Types","title":"Geometry Evolution","text":"","category":"section"},{"location":"api/core/#Accessing-Current-State","page":"Core Types","title":"Accessing Current State","text":"","category":"section"},{"location":"api/core/#Evolver-Interface","page":"Core Types","title":"Evolver Interface","text":"These are the methods that any level set evolver backend must implement:","category":"section"},{"location":"api/core/#Simulation-Snapshotting","page":"Core Types","title":"Simulation Snapshotting","text":"Types and functions for caching simulation state for visualization.","category":"section"},{"location":"api/core/#Types","page":"Core Types","title":"Types","text":"","category":"section"},{"location":"api/core/#Functions","page":"Core Types","title":"Functions","text":"","category":"section"},{"location":"api/core/#Visualization","page":"Core Types","title":"Visualization","text":"These functions require GLMakie to be loaded.","category":"section"},{"location":"api/core/#EvolvingDomains.EvolvingDiscreteGeometry","page":"Core Types","title":"EvolvingDomains.EvolvingDiscreteGeometry","text":"EvolvingDiscreteGeometry{E<:AbstractLevelSetEvolver}\n\nA wrapper that couples a level set evolver with a GridapEmbedded DiscreteGeometry.\n\nFields\n\nevolver: The backend that evolves the level set (implements AbstractLevelSetEvolver)\nbg_model: The background CartesianDiscreteModel\ngeometry: The current DiscreteGeometry (lazily regenerated when dirty)\ngeometry_dirty: Whether geometry needs rebuild (set after advance!)\ncached_cut: Cached EmbeddedDiscretization (lazily computed)\n\nPerformance Features\n\nLazy geometry rebuild: only rebuilds when accessed AND dirty\nCached cut geometry: avoids redundant cut() calls within same time step\n\nExample\n\neg = EvolvingDiscreteGeometry(evolver, model)\nadvance!(eg, 0.01)\ngeo = current_geometry(eg)   # Rebuilds geometry (lazy)\ncut_geo = current_cut(eg)    # Computes cut, caches result\ncut_geo2 = current_cut(eg)   # Returns cached, no recomputation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.AbstractLevelSetEvolver","page":"Core Types","title":"EvolvingDomains.AbstractLevelSetEvolver","text":"AbstractLevelSetEvolver\n\nAbstract type for level set evolution backends.\n\nAny backend must implement:\n\nevolve!(evolver, Δt): Advance the level set by time Δt\ncurrent_values(evolver): Return the current nodal level set values\ncurrent_time(evolver): Return the current time\nreinitialize!(evolver): Restore signed distance property\ngrid_coords(evolver): Return the grid node coordinates\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.LevelSetMethodsEvolver","page":"Core Types","title":"EvolvingDomains.LevelSetMethodsEvolver","text":"LevelSetMethodsEvolver <: AbstractLevelSetEvolver\n\nA level set evolver backend using LevelSetMethods.jl.\n\nFields\n\nequation: The LevelSetEquation from LevelSetMethods.jl\ncoords: Node coordinates as Gridap VectorValues  \nvelocity_source: The velocity source (AbstractVelocitySource or nothing)\nvelocity_buffer: Mutable buffer for velocity values (used with update_func)\n\nVelocity Modes\n\nStatic: Velocity sampled once at construction, never updated\nDynamic: Velocity re-sampled before each RK stage via update_func callback\n\nExample\n\n# Static velocity\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ0,\n    velocity = StaticFunctionVelocity(x -> (1.0, 0.0))\n)\n\n# FE-coupled velocity\nvel_source = FEVelocitySource(velocity_fh, model)\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ0,\n    velocity = vel_source\n)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.advance!","page":"Core Types","title":"EvolvingDomains.advance!","text":"advance!(eg::EvolvingDiscreteGeometry, Δt::Real; velocity=nothing, lazy=true)\n\nAdvance the geometry by time Δt. This evolves the level set.\n\nArguments\n\nΔt: Time step size\nvelocity: Optional velocity source to use for this advance\nlazy: If true (default), defer geometry rebuild until accessed\n\nPerformance\n\nWith lazy=true, geometry and cut are only rebuilt when accessed via current_geometry() or current_cut(). This avoids redundant rebuilds if you access the same geometry multiple times.\n\nExample\n\n# Using configured velocity (from evolver construction)\nadvance!(eg, 0.01)\n\n# With FE-coupled velocity\nvelocity_fh = solve_stokes(current_geometry(eg))\nadvance!(eg, 0.01; velocity=FEVelocitySource(velocity_fh, model))\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.reinitialize!","page":"Core Types","title":"EvolvingDomains.reinitialize!","text":"reinitialize!(evolver::AbstractLevelSetEvolver)\n\nRestore the signed distance property of the level set.\n\n\n\n\n\nreinitialize!(eg::EvolvingDiscreteGeometry)\n\nRestore the signed distance property. Marks geometry as dirty.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.invalidate_cache!","page":"Core Types","title":"EvolvingDomains.invalidate_cache!","text":"invalidate_cache!(eg::EvolvingDiscreteGeometry)\n\nForce invalidation of cached geometry and cut. Useful when external changes affect the geometry (e.g., manual level set modification).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_geometry","page":"Core Types","title":"EvolvingDomains.current_geometry","text":"current_geometry(eg::EvolvingDiscreteGeometry) -> DiscreteGeometry\n\nReturn the current DiscreteGeometry (for use with cut). Rebuilds geometry lazily if dirty.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_cut","page":"Core Types","title":"EvolvingDomains.current_cut","text":"current_cut(eg::EvolvingDiscreteGeometry) -> EmbeddedDiscretization\n\nReturn the current cut geometry, with caching. Computes cut(bg_model, geometry) only if not already cached.\n\nThis is more efficient than calling cut(model, current_geometry(eg)) multiple times within the same time step.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_time","page":"Core Types","title":"EvolvingDomains.current_time","text":"current_time(evolver::AbstractLevelSetEvolver) -> Float64\n\nReturn the current simulation time.\n\n\n\n\n\ncurrent_time(eg::EvolvingDiscreteGeometry) -> Float64\n\nReturn the current simulation time.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_levelset","page":"Core Types","title":"EvolvingDomains.current_levelset","text":"current_levelset(eg::EvolvingDiscreteGeometry) -> Vector{Float64}\n\nReturn the current nodal level set values.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.evolve!","page":"Core Types","title":"EvolvingDomains.evolve!","text":"evolve!(evolver::AbstractLevelSetEvolver, Δt::Real)\n\nAdvance the level set by time Δt. Modifies evolver in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.current_values","page":"Core Types","title":"EvolvingDomains.current_values","text":"current_values(evolver::AbstractLevelSetEvolver) -> Vector{Float64}\n\nReturn the current nodal values of the level set function.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.supports_velocity_update","page":"Core Types","title":"EvolvingDomains.supports_velocity_update","text":"supports_velocity_update(evolver::AbstractLevelSetEvolver) -> Bool\n\nReturn whether this evolver supports runtime velocity updates.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.SimulationFrame","page":"Core Types","title":"EvolvingDomains.SimulationFrame","text":"SimulationFrame\n\nA snapshot of simulation state at a specific time.\n\nFields\n\nt::Float64: Simulation time\nϕ::Matrix{Float64}: Level set values reshaped to grid (nx × ny)\n\nExample\n\nframe = snapshot(eg)\n@show frame.t\nheatmap(frame.ϕ)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.SimulationResult","page":"Core Types","title":"EvolvingDomains.SimulationResult","text":"SimulationResult{N}\n\nContainer for a sequence of simulation snapshots with grid metadata.\n\nFields\n\ngrid_info::CartesianGridInfo{N}: Grid metadata (origin, spacing, dims)\nframes::Vector{SimulationFrame}: Cached simulation frames\n\nExample\n\nframes = [snapshot(eg) for _ in 1:10 if (advance!(eg, Δt); true)]\nresult = SimulationResult(grid_info(eg), frames)\nviewer(result)  # Opens interactive viewer (requires GLMakie)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#EvolvingDomains.snapshot","page":"Core Types","title":"EvolvingDomains.snapshot","text":"snapshot(eg::EvolvingDiscreteGeometry) -> SimulationFrame\n\nCapture the current simulation state as a SimulationFrame.\n\nReturns a frame containing the current time and level set values  reshaped to the grid dimensions.\n\nExample\n\nframes = SimulationFrame[]\n\nfor step in 1:nsteps\n    # Your physics here...\n    advance!(eg, Δt)\n    \n    # Cache every 5 steps\n    if step % 5 == 0\n        push!(frames, snapshot(eg))\n    end\nend\n\nresult = SimulationResult(grid_info(eg), frames)\nviewer(result)  # Requires GLMakie\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.plot_levelset","page":"Core Types","title":"EvolvingDomains.plot_levelset","text":"plot_levelset(eg::EvolvingDiscreteGeometry; kwargs...)\n\nCreate an interactive contour plot of the current level set. Requires GLMakie: using GLMakie before calling.\n\nSee also: plot_levelset!\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.plot_levelset!","page":"Core Types","title":"EvolvingDomains.plot_levelset!","text":"plot_levelset!(ax, eg::EvolvingDiscreteGeometry; kwargs...)\n\nAdd level set visualization to an existing Makie axis. Requires GLMakie: using GLMakie before calling.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.viewer","page":"Core Types","title":"EvolvingDomains.viewer","text":"viewer(result::SimulationResult; wait=false, colormap=:RdBu) -> Figure\n\nOpen an interactive viewer with a time slider for cached simulation frames. Requires GLMakie: using GLMakie before calling.\n\nArguments\n\nresult: Cached simulation frames from snapshot() calls\nwait: If true, block until window is closed\ncolormap: Colormap for level set visualization\n\nExample\n\nframes = [snapshot(eg) for _ in 1:100 if (advance!(eg, Δt); true)]\nresult = SimulationResult(grid_info(eg), frames)\nviewer(result)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#EvolvingDomains.view_live!","page":"Core Types","title":"EvolvingDomains.view_live!","text":"view_live!(result::SimulationResult; fps=30, loop=false)\n\nPlay back cached simulation frames as an animation. Requires GLMakie: using GLMakie before calling.\n\nArguments\n\nresult: Cached simulation frames\nfps: Frames per second for playback\nloop: If true, loop animation continuously\n\nThis function blocks until playback completes (or Ctrl+C).\n\n\n\n\n\n","category":"function"},{"location":"examples/zalesak_disk/#zalesak_disk","page":"Zalesak Disk","title":"Zalesak's Rotating Disk","text":"The classic benchmark problem for level set methods: a slotted disk under rigid body rotation.","category":"section"},{"location":"examples/zalesak_disk/#Problem-Setup","page":"Zalesak Disk","title":"Problem Setup","text":"This standard test case evaluates the ability of level set methods to preserve sharp features during advection.\n\nDomain: -15 15^2\nGrid: 100 × 100 cells\nInitial shape: A disk of radius 0.5 centered at (-0.75, 0) with a rectangular slot\nVelocity: Rigid body rotation mathbfu(xy) = omega(-y x) with omega = 2pi","category":"section"},{"location":"examples/zalesak_disk/#Zalesak-Disk-Geometry","page":"Zalesak Disk","title":"Zalesak Disk Geometry","text":"The Zalesak disk is defined as a circle with a rectangular slot carved out:\n\nfunction zalesak_disk(x)\n    center = (-0.75, 0.0)\n    radius = 0.5\n\n    # Circle SDF: positive inside, negative outside\n    d_circle = radius - sqrt((x[1] - center[1])^2 + (x[2] - center[2])^2)\n\n    # Rectangular slot: centered on circle, extends upward\n    h = 1.0   # slot height\n    w = 0.2   # slot width\n\n    xmin = center[1] - w/2\n    xmax = center[1] + w/2\n    ymin = center[2]\n    ymax = center[2] + h\n\n    # Slot SDF: positive inside slot, negative outside\n    dx = min(x[1] - xmin, xmax - x[1])\n    dy = min(x[2] - ymin, ymax - x[2])\n    d_slot = min(dx, dy)\n\n    # Zalesak disk = circle minus slot (positive inside convention)\n    return min(d_circle, -d_slot)\nend","category":"section"},{"location":"examples/zalesak_disk/#Code","page":"Zalesak Disk","title":"Code","text":"using EvolvingDomains\nusing Gridap, GridapEmbedded\nusing LevelSetMethods\n\n# Domain setup\ndomain = (-1.5, 1.5, -1.5, 1.5)\npartition = (100, 100)\nmodel = CartesianDiscreteModel(domain, partition)\n\n# Rigid body rotation about origin\nω = 2π  # One revolution in T=1\nvelocity(x) = (-ω * x[2], ω * x[1])\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = zalesak_disk,\n    velocity = velocity,\n    spatial_scheme = :WENO5,\n    integrator = :RK3,\n    bc = :Neumann\n)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Store initial state for error comparison\nϕ_initial = copy(EvolvingDomains.current_levelset(eg))\n\n# Time stepping: one full revolution\nΔt = 0.005\nsubsteps = 4\nnsteps = 50\nreinit_freq = 5\n\nfor step in 1:nsteps\n    for _ in 1:substeps\n        EvolvingDomains.advance!(eg, Δt)\n    end\n\n    if step % reinit_freq == 0\n        EvolvingDomains.reinitialize!(eg)\n    end\nend\n\n# Error analysis\nϕ_final = EvolvingDomains.current_levelset(eg)\nerror_L2 = sqrt(sum((ϕ_final .- ϕ_initial).^2) / length(ϕ_initial))\nerror_Linf = maximum(abs.(ϕ_final .- ϕ_initial))\n\nprintln(\"L² error:   \", round(error_L2, sigdigits=4))\nprintln(\"L∞ error:   \", round(error_Linf, sigdigits=4))","category":"section"},{"location":"examples/zalesak_disk/#Error-Metrics","page":"Zalesak Disk","title":"Error Metrics","text":"After one complete revolution, we compute:\n\nL² error: RMS difference between initial and final level set values\nL∞ error: Maximum point-wise difference\nArea change: Relative change in the domain area\n\nA good level set method should minimize these errors while preserving the sharp slot features.","category":"section"},{"location":"examples/zalesak_disk/#Results","page":"Zalesak Disk","title":"Results","text":"(Image: Zalesak Disk Animation)\n\nThe WENO5 scheme with periodic reinitialization does a good job preserving the slotted disk shape throughout the rotation.","category":"section"},{"location":"examples/#Examples","page":"Overview","title":"Examples","text":"This section contains detailed examples demonstrating how to use EvolvingDomains.jl for various moving domain problems.","category":"section"},{"location":"examples/#Available-Examples","page":"Overview","title":"Available Examples","text":"","category":"section"},{"location":"examples/#[Rotating-Circle](@ref-rotating_circle)","page":"Overview","title":"Rotating Circle","text":"","category":"section"},{"location":"examples/#[Zalesak's-Rotating-Disk](@ref-zalesak_disk)","page":"Overview","title":"Zalesak's Rotating Disk","text":"","category":"section"},{"location":"examples/#[Colliding-Balls](@ref-colliding_balls)","page":"Overview","title":"Colliding Balls","text":"","category":"section"},{"location":"examples/#Running-the-Examples","page":"Overview","title":"Running the Examples","text":"The full example scripts (with visualization and animation) are available in the examples/ directory of the repository:\n\n# From the root of the repository\ninclude(\"examples/rotating_circle.jl\")\ninclude(\"examples/zalesak_disk.jl\")\ninclude(\"examples/colliding_balls.jl\")\n\nThe scripts require GLMakie and FFMPEG for visualization and video generation.","category":"section"},{"location":"examples/rotating_circle/#rotating_circle","page":"Rotating Circle","title":"Rotating Circle","text":"A simple example advecting a circle with a rigid body rotation velocity field.","category":"section"},{"location":"examples/rotating_circle/#Problem-Setup","page":"Rotating Circle","title":"Problem Setup","text":"We set up a circular domain on a background Cartesian grid and evolve it under rigid body rotation about the origin.\n\nDomain: -1 1^2\nGrid: 100 × 100 cells\nInitial shape: Circle of radius 0.2 centered at (0.3, 0.5)\nVelocity: Rigid body rotation mathbfu(xy) = omega(-y x) with omega = 2pi","category":"section"},{"location":"examples/rotating_circle/#Code","page":"Rotating Circle","title":"Code","text":"using EvolvingDomains\nusing Gridap, GridapEmbedded\nusing LevelSetMethods\n\n# Domain setup\ndomain = (-1.0, 1.0, -1.0, 1.0)\npartition = (100, 100)\nmodel = CartesianDiscreteModel(domain, partition)\n\n# Initial circle\nR = 0.2\ncenter = (0.3, 0.5)\nϕ₀(x) = R - sqrt((x[1]-center[1])^2 + (x[2]-center[2])^2)\n\n# Rigid body rotation about origin\nω = 2π  # Angular velocity (one revolution in T=1)\nu(x) = (-ω * x[2], ω * x[1])\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ₀,\n    velocity = u,\n    spatial_scheme = :WENO5,\n    bc = :Neumann\n)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Time stepping\nΔt = 0.01\nsubsteps = 2\nnsteps = 50\n\nfor step in 1:nsteps\n    for _ in 1:substeps\n        EvolvingDomains.advance!(eg, Δt)\n    end\n\n    # Reinitialize periodically to maintain signed distance property\n    if step % 5 == 0\n        EvolvingDomains.reinitialize!(eg)\n    end\nend\n\nprintln(\"Final time: \", EvolvingDomains.current_time(eg))","category":"section"},{"location":"examples/rotating_circle/#Visualization","page":"Rotating Circle","title":"Visualization","text":"With GLMakie loaded, you can visualize the final state:\n\nusing GLMakie\nfig = plot_levelset(eg; title = \"Rotating Circle (Final)\")","category":"section"},{"location":"examples/rotating_circle/#Results","page":"Rotating Circle","title":"Results","text":"The circle rotates about the origin while maintaining its shape. After one complete revolution (T=1), the circle should return to its starting position.\n\n(Image: Rotating Circle Animation)","category":"section"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"TODO","category":"section"},{"location":"examples/colliding_balls/#colliding_balls","page":"Colliding Balls","title":"Colliding Balls","text":"Two balls moving toward each other and merging.","category":"section"},{"location":"examples/colliding_balls/#Code","page":"Colliding Balls","title":"Code","text":"using EvolvingDomains\nusing Gridap, GridapEmbedded\nusing LevelSetMethods\n\n# Domain setup\ndomain = (0.0, 2.0, 0.0, 2.0)\npartition = (80, 80)\nmodel = CartesianDiscreteModel(domain, partition)\n\n# Two balls above and below y=1.0\ncenter_top = (1.0, 1.3)\ncenter_bottom = (1.0, 0.7)\nradius = 0.2\n\nfunction ϕ0(x)\n    # Positive inside convention: positive = inside ball\n    d_top = radius - sqrt((x[1] - center_top[1])^2 + (x[2] - center_top[2])^2)\n    d_bottom = radius - sqrt((x[1] - center_bottom[1])^2 + (x[2] - center_bottom[2])^2)\n    return max(d_top, d_bottom)  # Union of two balls\nend\n\n# Velocity: move toward y=1.0\nvelocity(x) = x[2] > 1.0 ? (0.0, -0.5) : (0.0, 0.5)\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ0,\n    velocity = velocity,\n    spatial_scheme = :WENO5,\n    integrator = :RK3,\n    bc = :Neumann\n)\neg = EvolvingDiscreteGeometry(evolver, model)\n\n# Time stepping\nΔt = 0.01\nsubsteps = 2\nnsteps = 30\n\nfor step in 1:nsteps\n    for _ in 1:substeps\n        EvolvingDomains.advance!(eg, Δt)\n    end\n\n    # Reinitialize periodically\n    if step % 10 == 0\n        EvolvingDomains.reinitialize!(eg)\n    end\nend\n\nprintln(\"Final time: \", EvolvingDomains.current_time(eg))","category":"section"},{"location":"examples/colliding_balls/#Visualization","page":"Colliding Balls","title":"Visualization","text":"With GLMakie loaded:\n\nusing GLMakie\n\n# Initial state\nfig_initial = plot_levelset(eg; title = \"Initial: Two Balls\")\n\n# Final state (after collision)\nfig_final = plot_levelset(eg; title = \"Final: Merged\")","category":"section"},{"location":"examples/colliding_balls/#Results","page":"Colliding Balls","title":"Results","text":"TODO","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/naoufelcre/EvolvingDomains.jl\")\n\n# Also install the level set backend (not yet registered)\nPkg.add(url=\"https://github.com/maltezfaria/LevelSetMethods.jl\")","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"EvolvingDomains.jl builds on top of several Julia packages:\n\nGridap.jl: Finite element framework\nGridapEmbedded.jl: Cut-cell methods for embedded boundaries\nLevelSetMethods.jl: High-order level set advection\n\nThese will be installed automatically as dependencies.","category":"section"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/#1.-Create-a-Background-Grid","page":"Getting Started","title":"1. Create a Background Grid","text":"using Gridap\n\ndomain = (0.0, 1.0, 0.0, 1.0)\npartition = (50, 50)\nmodel = CartesianDiscreteModel(domain, partition)","category":"section"},{"location":"getting_started/#2.-Define-Initial-Geometry","page":"Getting Started","title":"2. Define Initial Geometry","text":"The geometry is defined implicitly via a level set function phi(x):\n\nphi  0: Inside the domain\nphi = 0: Interface\nphi  0: Outside\n\n# Circle centered at (0.5, 0.5) with radius 0.2\nR = 0.2\nϕ₀(x) = R - sqrt((x[1]-0.5)^2 + (x[2]-0.5)^2)","category":"section"},{"location":"getting_started/#3.-Create-the-Evolver-and-Evolving-Geometry","page":"Getting Started","title":"3. Create the Evolver and Evolving Geometry","text":"using EvolvingDomains\nusing LevelSetMethods\n\n# Define velocity field\nu(x) = (1.0, 0.0)  # Constant rightward flow\n\n# Create evolver\nevolver = LevelSetMethodsEvolver(;\n    bg_model = model,\n    initial_ls = ϕ₀,\n    velocity = u,\n    spatial_scheme = :WENO5,\n    bc = :Neumann\n)\n\n# Create evolving geometry wrapper\neg = EvolvingDiscreteGeometry(evolver, model)","category":"section"},{"location":"getting_started/#4.-Time-Stepping","page":"Getting Started","title":"4. Time Stepping","text":"using GridapEmbedded\n\nfor step in 1:100\n    advance!(eg, 0.01)  # Move geometry\n\n    # Use current geometry with Gridap\n    geo = current_geometry(eg)\n    cut_geo = cut(model, geo)\n\n    # ... solve physics on cut_geo ...\nend","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Examples\nVisualization\nAPI Reference","category":"section"},{"location":"api/velocity/#Velocity-Sources","page":"Velocity Sources","title":"Velocity Sources","text":"","category":"section"},{"location":"api/velocity/#Velocity-Source-Types","page":"Velocity Sources","title":"Velocity Source Types","text":"","category":"section"},{"location":"api/velocity/#Velocity-Extension-Strategies","page":"Velocity Sources","title":"Velocity Extension Strategies","text":"When using FE velocities that are only defined inside the domain, velocity extension strategies determine how to compute velocities at interface nodes.","category":"section"},{"location":"api/velocity/#Functions","page":"Velocity Sources","title":"Functions","text":"","category":"section"},{"location":"api/velocity/#EvolvingDomains.AbstractVelocitySource","page":"Velocity Sources","title":"EvolvingDomains.AbstractVelocitySource","text":"AbstractVelocitySource\n\nAbstract type for velocity sources used in level set advection.\n\nImplementations must define:\n\nsample_velocity(source, coords, t): Sample velocity at coordinates and time\nis_time_dependent(source): Whether velocity varies with time\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.StaticFunctionVelocity","page":"Velocity Sources","title":"EvolvingDomains.StaticFunctionVelocity","text":"StaticFunctionVelocity{F, E<:AbstractVelocityExtension} <: AbstractVelocitySource\n\nVelocity source from a static function u(x) -> velocity. The velocity is time-independent and sampled once per call.\n\nFields\n\nfunc: Function x -> SVector{2,Float64} or tuple\nextension: Velocity extension strategy\n\nExample\n\nu(x) = (1.0, 0.0)  # Constant rightward flow\nvel_source = StaticFunctionVelocity(u)\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.TimeDependentVelocity","page":"Velocity Sources","title":"EvolvingDomains.TimeDependentVelocity","text":"TimeDependentVelocity{F, E<:AbstractVelocityExtension} <: AbstractVelocitySource\n\nVelocity source from a time-dependent function u(x, t) -> velocity.\n\nFields\n\nfunc: Function (x, t) -> SVector{2,Float64} or tuple\nextension: Velocity extension strategy\n\nExample\n\nu(x, t) = (-x[2], x[1]) * cos(t)  # Oscillating rotation\nvel_source = TimeDependentVelocity(u)\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.FEVelocitySource","page":"Velocity Sources","title":"EvolvingDomains.FEVelocitySource","text":"FEVelocitySource{V, M, E<:AbstractVelocityExtension} <: AbstractVelocitySource\n\nVelocity source wrapping a Gridap CellField (FEFunction) with optimized sampling.\n\nSupports two sampling modes:\n\nPoint evaluation (fallback): Calls fh(Point(x,y)) for each node\nFast DOF path (with NarrowBandExtension): Direct DOF array access + extension\n\nFields\n\nfe_function: Current velocity CellField (mutable for in-place updates)\nbg_model: Background CartesianDiscreteModel\nextension: Velocity extension strategy\nlevelset_values: Level set values at grid nodes (for narrow band)\ninside_mask: Nodes inside physical domain (ϕ < 0)\n\nExample\n\n# Basic usage (point evaluation)\nvel_source = FEVelocitySource(velocity_fh, model)\n\n# Fast path with narrow band extension\nnx, ny = partition .+ 1\nγ = 6 * Δx  # 6 cells bandwidth for WENO5\next = NarrowBandExtension(γ, nx, ny)\nvel_source = FEVelocitySource(velocity_fh, model, ext)\n\n# Update level set values (needed for narrow band)\nupdate_levelset!(vel_source, ϕ_values)\n\n# When velocity is updated from new FE solve\nupdate_velocity!(vel_source, new_velocity_fh)\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.AbstractVelocityExtension","page":"Velocity Sources","title":"EvolvingDomains.AbstractVelocityExtension","text":"AbstractVelocityExtension\n\nAbstract type for velocity extension strategies.\n\nUsed when evaluating velocity at points outside the physical domain (e.g., ghost points near cut cells). Implementations define how to extrapolate or extend the velocity field.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.NoExtension","page":"Velocity Sources","title":"EvolvingDomains.NoExtension","text":"NoExtension <: AbstractVelocityExtension\n\nDefault extension: use velocity as-is (assumes all sample points are valid).\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.ZeroExtension","page":"Velocity Sources","title":"EvolvingDomains.ZeroExtension","text":"ZeroExtension <: AbstractVelocityExtension\n\nZero extension: return zero velocity for points outside domain.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.ConstantExtension","page":"Velocity Sources","title":"EvolvingDomains.ConstantExtension","text":"ConstantExtension <: AbstractVelocityExtension\n\nConstant extension: use a fixed velocity for points outside domain.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.NarrowBandExtension","page":"Velocity Sources","title":"EvolvingDomains.NarrowBandExtension","text":"NarrowBandExtension <: AbstractVelocityExtension\n\nOsher-Sethian narrow band velocity extension.\n\nExtends velocity from inside nodes to a narrow band around the interface using constant extrapolation in the normal direction (∇u · ∇ϕ = 0).\n\nFields\n\nbandwidth: Width of narrow band γ (should be k × Δx where k ≥ stencil width)\nnx, ny: Grid dimensions for 2D neighbor lookup\nmax_iters: Maximum extension iterations (default: 50)\n\nNotes\n\nVelocity outside the narrow band is set to zero, as it doesn't affect level set evolution near the interface.\n\n\n\n\n\n","category":"type"},{"location":"api/velocity/#EvolvingDomains.sample_velocity","page":"Velocity Sources","title":"EvolvingDomains.sample_velocity","text":"sample_velocity(source::AbstractVelocitySource, coords, t) -> Vector{SVector{2,Float64}}\n\nSample velocity at grid coordinates and time t. Returns a vector of 2D velocity vectors, one per coordinate.\n\n\n\n\n\nsample_velocity(source::FEVelocitySource, coords, t)\n\nSample velocity at grid coordinates.\n\nIf extension is NarrowBandExtension and levelset_values is set, uses the fast DOF-based path with narrow band extension. Otherwise falls back to point evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.is_time_dependent","page":"Velocity Sources","title":"EvolvingDomains.is_time_dependent","text":"is_time_dependent(source::AbstractVelocitySource) -> Bool\n\nReturn whether velocity varies with time. If false, velocity is sampled once at construction and cached.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.update_velocity!","page":"Velocity Sources","title":"EvolvingDomains.update_velocity!","text":"update_velocity!(evolver::AbstractLevelSetEvolver, velocity_source, t)\n\nUpdate the evolver's internal velocity representation from an external source. Called before each time step when using time-dependent or FE-coupled velocities.\n\nDefault implementation does nothing (for static velocity cases). Override this for evolvers that support velocity updates.\n\n\n\n\n\nupdate_velocity!(source::FEVelocitySource, new_fh)\n\nUpdate the wrapped FE velocity function with a new solution.\n\n\n\n\n\nupdate_velocity!(evolver::LevelSetMethodsEvolver, new_source::AbstractVelocitySource, t)\n\nUpdate the evolver's velocity source. The new source will be sampled at the next RK stage via the update_func callback.\n\n\n\n\n\nupdate_velocity!(evolver::LevelSetMethodsEvolver, fh, t)\n\nConvenience method: if an FEVelocitySource is already set, update its wrapped function. Otherwise, create a new FEVelocitySource.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.extend_velocity","page":"Velocity Sources","title":"EvolvingDomains.extend_velocity","text":"extend_velocity(ext::AbstractVelocityExtension, vel, x, domain_indicator)\n\nExtend velocity vel at point x. The domain_indicator function returns whether a point is inside the physical domain.\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.extend_velocity_narrow_band!","page":"Velocity Sources","title":"EvolvingDomains.extend_velocity_narrow_band!","text":"extend_velocity_narrow_band!(vel, ϕ, inside_mask, ext::NarrowBandExtension)\n\nExtend velocity from inside nodes to narrow band using neighbor propagation.\n\nUses iterative relaxation: each outside node in the narrow band copies velocity from its neighbor with smallest |ϕ| that already has velocity.\n\nThis approximates the PDE extension ∇u · ∇ϕ = 0 (constant in normal direction).\n\n\n\n\n\n","category":"function"},{"location":"api/velocity/#EvolvingDomains.update_levelset!","page":"Velocity Sources","title":"EvolvingDomains.update_levelset!","text":"update_levelset!(source::FEVelocitySource, ϕ::Vector{Float64})\n\nUpdate the level set values for the narrow band extension. Also recomputes the inside_mask.\n\n\n\n\n\n","category":"function"},{"location":"#EvolvingDomains.jl","page":"Home","title":"EvolvingDomains.jl","text":"A very minimal Julia package for evolving domain simulations in the Gridap Ecosystem.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"EvolvingDomains.jl provides basic structure to solves PDE's on moving domains. It can be used as a basic building block for Multi-Physics simulation building with operator splitting techniques. It is designed to fit in the Gridap.jl ecosystem.","category":"section"},{"location":"#Package-Contents","page":"Home","title":"Package Contents","text":"","category":"section"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"Pages = [\n    \"getting_started.md\",\n    \"examples.md\",\n    \"api/core.md\",\n    \"api/velocity.md\",\n    \"api/external.md\",\n]\nDepth = 2","category":"section"}]
}
